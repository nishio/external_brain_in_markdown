---
title: "一部の関数が頻繁に変更されるライブラリ"
---

- コマンドラインで実行してユーザが対話的に操作するスクリプトAがある
- Aの中からある関数Bが呼ばれる
    - 具体的には特徴量ベクトルの作成
    - これはスクリプトAのユーザがガシガシ書き換えて試行錯誤する
- 全体をモジュールとしてインポートして使うことも可能
    - このモジュールを学習させることがスクリプトAの目的で、関数Bを書き換えるのもモジュールとしての改善のため
    - スクリプトAを使うフェーズとコマンドラインで対話的に使うフェーズはオーバーラップしうる
この状況で「Bの部分はガシガシ書き換えるから別ファイルにくくりだした方がいいかな」と思ったのだが何が何をインポートする形にすればいいのだろうか。

案0: コマンドラインで実行するcli.pyとユーザがいじるuser.pyに分けた場合
- ユーザはcli.pyを実行する
- ユーザはuser.pyを編集する
- cliからimport userする
- cliが十分枯れた場合、ユーザは中身を読む必要もないし、プロジェクトごとにある必要もないので一本化するのは手
- だけど枯れるまでは不用意に場所を分散させるよりも一箇所にまとまってた方がいいのでは

パッケージの中のファイルをスクリプトとして実行した時にそのファイルからパッケージの他のファイルをrelative importできない、なぜならそのファイルはそこがパッケージの中だと思ってないから
:

```
.
└── foo
    ├── A.py
    ├── B.py
    ├── __init__.py
```

この状況で、A.pyの中に`import B`と書いてあった場合、`$ python A.py` はOKだが `python -c "import foo.A"`だとBを見つけられない。逆に`import .B`と書いてあった場合は`$ python A.py`でNG。

結局、実行スクリプトはモジュールの外に置くことにした
:

```
.
├── LICENSE
├── README.md
├── cli.py
├── ppoi
│   ├── main.py
│   ├── negative.txt
│   ├── neutral.txt
│   ├── positive.txt
│   ├── unknown.txt
│   └── user.py
└── samples
    └── unknown.txt
```




案1: ユーザの好きなスクリプトuser.pyから関数Bを登録した上でCLI機能を呼び出して使う
user.py

```
import ppoi

@ppoi.add_feature
def B(x):
	return 1

if __name__ == "__main__":
	ppoi.main()
```

この場合、モジュールとしてインポートして使う場合にもこのuser.pyは実行される必要があるから、モジュールとしてのAPIは(このスクリプトの中で使わないとしても)`from ppoi import to_bool, to_prob`とかやっておく必要がありそう。

この場合、ppoiがプロジェクト内になくても良い

案2: 関数名を決め打ちにして`ppoi user.py`で呼び出す。ppoiがuser.pyをインポートして特定名の関数にアクセスする。
