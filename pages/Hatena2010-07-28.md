---
title: "Hatena2010-07-28"
---

hatena

```
<body>
*1280318211*講義資料の続き
<a href='http://practical-scheme.net/trans/beating-the-averages-j.html'>Beating the Averages</a>
>>
プログラミング言語は半分技術で、半分は宗教なんだ [注6]
...
注6: 結果として、プログラミング言語の 比較は宗教戦争になるか、中立であろうとするあまりに 人類学の研究かと見まごうような学部生用の教科書にしかならない。 平和を好むか、大学での終身雇用を手に入れたい人は、この話題を避けて通る。 でも、宗教的な部分はこの問題の半分だけなんだ。他の部分には研究すべき価値がある。 特にあなたが新しい言語を設計したいと思っている時には。 
<<

というわけで、本当はもう少し宗教論争的な意味で炎上することを期待していたんだけどなー。真面目に書きすぎだと複数人に指摘された(苦笑)
炎上してから公開するつもりだった原稿の続き:

<hr>

賢者は歴史から学ぶ。愚者は経験からしか学ばない。

自分で適当な設計で作って罠にはまる前に、既存の言語処理系を色々見比べて、どんな設計を採用したのか、どういう失敗をしたのかを学ぶことが重要だ。
しかし言語間比較は不毛な論争を招きやすい。

なぜか？

<hr>

ある設計上の問題に対して解決策Aと解決策Bはどちらがよいのだろうか？
例えばGCはデフォルトでONがいいのか、それとも必要な人だけ使えるのがいいのか？
文字列は破壊的に変更できる方がいいのかできない方がいいのか？
整数や多倍長整数や浮動小数点数や文字列の間の暗黙の型変換はある方がいいのかない方がいいのか？

**「選択肢Aが正解だ」
と言えると思っている？
それは視野が狭い。
現実社会の問題の大部分は簡単に割り切れない「ケースバイケース」な問題だ。

メモリの消費量や実行時間にシビアでないケースではGCまかせにしたほうがプログラマは楽かもしれない。
しかし組み込みでメモリがとても少ない場合や、例えばシューティングゲームみたいにゲーム中にGCが走るとユーザがイラッとする場合などGCまかせにしたくないケースはいくつもある。

- 議論のしかた　「正しさ」の問題  http://iwatam-server.sakura.ne.jp/software/giron/giron/ar01s05.html

唯一の正解があるはずだという思い込みは不毛な議論を招きやすい。
<hr>

よく起こる不毛な議論のパターン：「宗教論争」「自転車置場の議論」

** 宗教論争とは
言語Xと言語Yのユーザがそれぞれ「自分の使っている言語の設計/機能が正しい」と考え、相手の言語の設計を「自分の信じる正しい言語と設計/機能が違う」という理由で互いに批判する状態。(一般的には言語の設計に限らずエディタやOS、政治、そして宗教も対象になる)

言語Xの信者が主張する「正しさ」が「言語Xに近いこと」なので、何が正しいのかについて意見がまとまるはずがない。不毛な議論である。


** 宗教論争はなぜ起こるか
全ての言語を均等に知っている人はいないので、どんな人の発言にも「彼の得意な言語がなんであるか」に起因する偏りがある。
人間には自分の慣れたものに愛着を感じる傾向があるので、自分の得意な言語をほめすぎることが多い。
また自分の知らないものの価値を認めることは難しい。よって自分の知らない言語のユーザが自分のよく知らないくだらない機能を高く評価し崇め奉っている「信者」にみえてしまう。

また、特に1つの言語に愛着が強い場合、その言語の欠点を指摘されるとたとえ的を射ていようが「自分に対する攻撃」と感じてしまい、防衛のための反論をしがち。


** 自転車置場の議論とは
駐輪場に屋根をつけるかどうか、何色に塗るか、といった些細な問題ほど議論に参加する人が多くなる現象。
プログラミング言語で言えばsleepの引数が秒であるべきかミリ秒であるべきか、文字列のリストを結合するのはString#joinであるべきかList#joinであるべきか、配列の各要素に関数を適用するメソッドの名前が map であるべきか collect であるべきか、などの議論。
こういう議論が無意味なわけではないが、大勢で考えなければいけないような問題でもないし、必死になって自分の主張を貫くような価値のある対象でもない。

-自転車置場の議論 - bkブログ
-http://0xcc.net/blog/archives/000135.html
-FreeBSD FAQ
-http://www.freebsd.org/doc/ja_JP.eucJP/books/faq/misc.html#BIKESHED-PAINTING

** 自転車置き場の議論はなぜ起こるか
人間には「他者から関心・注目・反応が欲しい」という承認欲求がある。承認欲求に飢えている生き物にとって、大勢が参加する議論に加わるのはいいエサだし、万が一自分の意見が通りでもしようものならすごいご馳走だ。
だから簡単そうな問題にはまず素早い人が口を挟み、議論の参加者が増えたことで自分も一言噛んでおこうと思う人でますます議論が紛糾し、そして彼らは自分の名誉と注目を守るために必死に他の意見を貶めようと発言する。


** ある種の自然現象
宗教論争も駐車場の議論も、人間がそういう性質の生き物だから起きる自然現象だ。自分が起こさないように努力をすることは必要だが、起きてしまったことに嘆いたり怒ったりしても無意味。夏が暑くて時々夕立になることと同じ。夕立をふらせた雲に文句を言っても雨はやまない。

夕立に怒るのでも夕立が降るのを嘆くのでもなく、夕立の時には雨宿りをして、濡れて風邪をひかないようにするのが賢明。

<hr>
「PEPのススメ」に続く。

*1280325373*抜粋翻訳 PEP3138 String representation in Python 3000
PEP3138 String representation in Python 3000

**概要
この文章では、Python 3000用に文字列の新しい表現方法を提案する。 Python 3000以前のPythonでは、組み込み関数repr()はデバッグやログ出力のために、任意のオブジェクトを画面表示可能なASCIIの文字列に変換していた。 Python 3000ではユニコード標準に基づいて、より広い範囲の文字を「画面表示可能」とみなすべきである。

**動機
Python2.*系では「表示可能な文字列を作成する関数」reprは、非ASCII文字をすべてエスケープする。文字列を構成する文字のほとんどがASCIIである場合には問題にならない。しかし、日本語などいくつかの言語ではほとんどの文字が非ASCIIであり、とても不便である。

例えば open(japaneseFilemame) が何か例外を投げる場合、エラーメッセージは IOError: [Errno 2] No such file or directory: '\u65e5\u672c\u8a9e' といったものになる。

Python 3000 には、非ASCII識別子など、ラテン文字以外を使用しているユーザーに優しい特徴がたくさん盛り込まれている。表示可能な文字列の作成に関しても同様に進化できればきっと役に立つことだろう。

*1280328433*抜粋翻訳 PEP 236 Back to the __future__
PEP 236 Back to the __future__

**動機

時が立つにつれて、Pythonは言語コアの構造の広く知られた意味づけに互換性のない変更を加えたり、思いがけない(実装依存の)振る舞いを何らかの形で変更したりする。こういう変更は気まぐれには行われず、常に長期的に見て言語を改善する目的で行われるのだが、しかし短期的には論争と混乱を呼ぶものである。

PEP 5, Guidelines for Language Evolution[1] は痛みを減らす方法を提案している。このPEPでは、それを実現するためのメカニズムを導入する。

**意図
言語コア部分の構文や意味論に互換性のない変更を加える際は:

    1. その変更が導入されるリリースCでは構文や意味論をデフォルトでは変更しない。

    2. ある将来のリリースRを、そこでその構文や意味論が強制されるものとする。

    3. PEP 3, Warning Framework[3] で説明されているメカニズムが、リリースRで意味を変えるであろう操作や構成について、可能な限りいつでも、警告を作成するのに使われる。

    4. モジュールMの中のコードが現在のリリースCで新しい構文や意味論を使うことを要求するために、新しい future_statement (後述) を明示的にモジュールMに含めることが出来る。

つまり、古いコードは少なくとも一つのリリースでデフォルトで動き続け、しかし新しい警告メッセージを表示しはじめるようになる。新しい構文や意味論への移行はこの期間中に進めることができ、future_statementを使って、それを含むモジュールがすでに新しい構文と意味論が強制されたあとであるかのように振舞うようにできる。

*1280333246*抜粋翻訳 PEP 3107 Function Annotations 
** 概要
このPEPはPythonの関数に、任意のメタデータを追加するための構文を導入する。

** 根拠
Python 2.x 系は関数の引数と返り値を修飾する方法を持たなかったため、数多くのツールやライブラリがそのギャップを埋めるために現れた。いくつかは PEP 318 で導入されたデコレータを使い、他のいくつかは関数のドキュメンテーション文字列をパースしてアノテーションを探す。

このPEPは、このような情報を指定する、唯一の標準的な方法を提供し、今現在幅広い方法と構文のバリエーションが引き起こしている混乱を軽減することを目指している。

** 関数アノテーションの前提

-関数アノテーションは、パラメータと戻り値の両方とも、完全に任意。
-関数アノテーションはコンパイル時に任意のPythonの式を関数のさまざまな部分に関連付ける方法以上のなにものでもない。Pythonそれ自体はアノテーションに特定の意味をもたせることはしない。

>|python|
def compile(source: "something compilable",
            filename: "where the compilable thing comes from",
            mode: "is this a single statement or a suite?"):
    ...
||<

>|python|
def haul(item: Haulable, *vargs: PackAnimal) -> Distance:
    ...
||<
</body>
```


[はてなダイアリー 2010-07-28](https://nishiohirokazu.hatenadiary.org/archive/2010/07/28)