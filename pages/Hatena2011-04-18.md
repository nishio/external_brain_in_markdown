---
title: "Hatena2011-04-18"
---

hatena

```
<body>
*1303091592*ポモドーロ再考
Twitterより転載
>>
ポモドーロの肝はPDCAのCの部分だと思う。僕が割り込みの比較的少ない職場なのになぜプラン通りに作業ができていないのかをチェックするには割り込み頻度にフォーカスしたレコードでは足りなくて、ポモドーロ終わったのに作業を続けてしまうとか、タイマー付けずに作業しちゃうとかも計測されるべき
<<

** 何をレコードすべきか

ここしばらくポモドーロ作業をしていて起きた割り込み
- 地震
- 話しかけられる
一日平均1回未満だと思う。きっと割り込みの少ない職場のはず。だから僕の生産性向上に関しては割り込みを減らすことより、もっと別の注力すべき課題があるはず。

バッドパターン
- タイマーを回さないで作業をして、カウントされるべきポモドーロがカウントされない
-- 休み時間に調べ物をしていたら、そのまま作業に移行していて1ポモドーロくらいの時間を使っていたが計測していない
-- 休み時間の調べ物が予想以上に手間取って気がついたら1ポモドーロ分くらい調べ物をしているが計測していない
-- ポモドーロが終了した後「あとちょっとでこのバグが取れるから！」とそのまま作業したらちょっとで取れなくて結構時間を使ったけどどれくらい使ったかわからない
- 会議や勉強会などの予定との間に1ポモドーロ未満の時間があって仕事が手につかない

良くも悪くも「のめりこむ」傾向がある。まずはきちんと計測して定量的に評価出来るようにしなければ改善のしようがない。計測せずに行ってしまったタスクがどの程度あるかを記録するべきか。ポモドーロ開始時に時刻を記録すれば、休み時間が不自然に長い時には異常値だときづけるはずだ。それは何らかの理由でやる気をなくしているか、記録せずに仕事にのめり込んでいるか、タスクリストに載ってない作業をやっているか、だ。改善すべき対象だ。

後者の「細切れ時間」に関しては「細切れ時間タスク」をやるべき。

** タスクをテキストでどう表現するか

細切れ時間タスクの扱いが苦手な理由の一つに、その表記法が決まっていないことが考えられる。

サイボウズラボに入って覚えたことの一つに「未処理タスクを□、処理済みタスクを■で表現する」という記法があって、これはとても気に入っているので「とど(todo)」と「どね(done)」で変換できるようIMEに登録している。これは今まで僕の中では一つのタスクにつき一つの□というルールで運用されてきていて、ポモドーロを始めたときに□□□で3ポモドーロ、という拡張の仕方をした。これは正しくない拡張だ。なぜなら1ポモドーロ未満のタスクが管理できなくなる。3ポモドーロで終わると予想して2ポモドーロで終わったら■■□で完了していないタスクに見える。1ポモドーロで終わると思ったけど終わらなかったタスクが■になって終わったみたいに見える。

以前テキストエディタでポモドーロを管理している人がブログに自分の記法を書いているのをちらりと見たのだけど、それを参考にしようと検索しても見つけられなくて困った。仕方が無いので新しく考えてみよう。

僕の今までの習慣に合わせるためには、タスクの頭には一つの□があって、それはタスク完了時に■に変わる。このルールを変えてはいけない。一方でポモドーロとしては「タスク開始前に何ポモドーロで完了するかの予測をする」「作業中の割り込みを記録する」「見積もり通りに終わらなかったことも記録する。どれくらいのポモドーロを追加すれば終わると考えたか、そしてその見積りが正しかったかも」が必要。というわけで

>||
- ほげプロジェクト
-- □xoo 何とかの準備
||<

ポモドーロをo、消費したポモドーロをx、リスケをxxx|ooみたいに表現するのはどうか。割り込みによって潰れたポモドーロを同表現するか。zとかか？1ポモドーロ未満のタスクは.にするか？何も付けないのはよくない。かかる時間の見積もりをまだやっていないタスクと区別が付かなくなる。zと.に関してはその記号でいいか使ってみて検討しよう。

** まとめ
>||
凡例: □xxx|xoo 割り込みはz、1未満タスクは.、タイマー回しそこねは?で表現
ルール: 細かいタスクでもとりあえずタイマーを回す。
||<
ここまでの整理に1ポモドーロかかった。

*1303109263*Pythonでサブプロセスと対話する
標準入力に1行入れると、標準出力で1行返してくるようなプログラムがあって、起動のたびに7分かかってめんどうだから、プロセスを起動しっぱなしにしておいてHTTPサーバで包んでやろうと思ったんですよ。

サブプロセスの挙動としてはcatだと思っていい。それで

>|python|
p = Popen(["cat"], stdin=PIPE, stdout=PIPE)
||<
ってやってから
              
>|python|
p.stdin.write("%s\n" % query)
result = p.stdout.read()
||<

ってやるとブロックされてしまった。ブロックを避けるために生のread/writeではなくp.communicateを使えとマニュアルには書いてあるが、それを使うと1回やり取りした時点でfdを閉じてしまうから2回目で「ValueError: I/O operation on closed file」になる。p.stdin.flush()は関係なし。p.stdout.read(1)ならブロックせずに読める。つまりはPythonのfile#read()がread(1024)みたいな挙動をして、しかも指定された量のデータがない場合にブロッキングすることが原因。POSIXのreadは
>>
It is not an error if this number is smaller than the number of bytes requested; this may happen for example because fewer bytes are actually available right now...
<<
という挙動をするので、POSIX環境でコードを書いているならos.readを使えばよい。

>||
>>> p.stdin.write("hoge\n")
>>> os.read(p.stdout.fileno(), 1024)
'hoge\n'
||<

thanks id:moriyoshi, id:mopemope

追記: 1行単位で返ってくることが既知ならreadlineでもいいと言う指摘が多数ありました。
</body>
<comments>
<comment>
<username>methane</username>
<body>サブプロセスが cat のように改行単位でバッファリングするのであれば、 p.readline() を使えますよ。</body>
<timestamp>1303110631</timestamp>
</comment>
</comments>
```


[はてなダイアリー 2011-04-18](https://nishiohirokazu.hatenadiary.org/archive/2011/04/18)