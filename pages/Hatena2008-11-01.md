
hatena

```
<body>
*1225517718*[最中限]気がついたら
しばらく最中限をいじれないでいるうちにすごく高速化されていた。
http://shinh.skr.jp/m/?date=20081028
http://homepage1.nifty.com/herumi/diary/0810.html#30

「vectorを使ってeraseとかしてるのが遅い」って突っ込まれるのはわかっていたので、それを直してから実行時間を比較しようと思っていたのだけどソースコードがCodeReposに上がっているので直す前に添削されちゃった。まぁ公開していなかったらこの面白い高速化話は読めなかったかもしれないので「これを今の状態で出したらつっこまれるんじゃないか」って恐怖心で公開しないことは機会損失なんだなぁ、と思った。

>>
コードを読む。うーん中二病チックなのは素晴らしいから良いとして、 think_[a23]_turns? って関数はメンテしずらいと思うがー
<<

うーん、think_a_turnは最終ターンだから「次のターンに使える手札のリスト」を作成する必要がなく、think_3_turnsはラウンド冒頭だからラウンドスコアが[0, 0, 0]なのでそれにターンで得た得点を足し算をする必要がない。この3つの関数をまとめることはできるけど、無駄なコストを支払わずにまとめる方法はわからなかったのでわけてある。

>>
たぶん、このコードは全探索できてない。

　for(size_t i=0; i < N; i++){
　　cards rest1 = except_one(unknowns, i);
　　for(size_t j=i+1; j < N; j++){

とかでぶんまわしてるけど、これは敵2人が違う点数の場合はそれじゃあかんやろ、と思う。
<<

一番よけいな処理の少ないthink_a_turnで説明しよう。

>|cpp|
    for(size_t i=0; i < N; i++){
      for(size_t j=i+1; j < N; j++){
	eval_value s = measure(my, unknowns[i], unknowns[j], round_score);
	if(my == get_center(my, unknowns[i], unknowns[j])){
	  // winner is me. 
	  score += s * 2;
	}else{
	  score += s;
	  score += measure(my, unknowns[j], unknowns[i], round_score);
	}
      }
    }
||<

ターンで自分が真ん中のときには、残りの二人の出した手を入れ替えても結果が変わらない。だから片方の処理だけやって2倍してもかまわない。いっぽう、自分が真ん中でない場合にはペアをひっくり返したバージョンを改めて計算している。約1/3のケースで2回の処理を1回で済ませられる。

>>
ちなみに、速くする方法としては、どうせカードは 52 枚しか無いんだから、読みを開始する前に bool seen[52] とか作っておいて、カード使うたびにこれを false とか true とか切り替えてやるのがまぁあからさまに高速化できると思う。
<<

それってこういうこと？
>|cpp|
       for(size_t i=0; i < 52; i++){
           if (seen[i]) continue;
           for(size_t j=0; j < 52; j++){
               if (seen[j]) continue;
||<

これが速いってそんなにあからさまにわかるものかなぁ。
最終ターンの読み切りにおいて、本当だったら5 * 11 * 10回のループで済むところが52 * 52 * 52回にふくれあがるわけだよね。大半の回では単に配列から値を取り出してjumpするだけの簡単なお仕事とはいえ、この関数は上流から6 * 13 * 12 * 7 * 15 * 14回呼び出されるわけなので、そのコスト増が許容できるかどうか自明じゃない気がする。まぁもちろんvectorを確保し直したりするのは遅いと思う。

順序関係ないから手札[1, 2, 3, 4, 5]で3を使ったときには3と5をswapして[1, 2, 5, 4, 3]にして「手持ちの札は4枚」って情報を持っておくのが速いのかなぁ。

*1225525027*[cpp]探索のパフォーマンスはどうやって比較すればいいか
「N個の要素が与えられて、その中からM個を選んだ順列について何かを計算したい」というときの要素のたどり方って何が最速なんだろう。そしてどれが最速かを調べるベンチマークってどうやって書いたらいいんだろう。まわりのループの部分だけ書いたらコンパイラが「これは何もしていない」とか言って消してしまいそうだし、N個の要素だってうっかりプログラム中に記述するとコンパイルタイムにある程度計算されてしまったりしそうだ。


入力はまぁ、コマンドライン引数で渡すことにしてしまえばいいか。


あとは、なるべく処理時間を食わなくて、かつコンパイラが消さないようななにかを... グローバル変数を1個用意して、それに順列の各値を足すとか？

*1225530500*ダイエット
f:id:nishiohirokazu:20081101180521p:image

年齢相応まで脂肪を落としてみた。結局のところ、何も考えずに毎日ピルクル飲んだり、毎朝ご飯にシーチキン食べたり、毎昼ご飯にすきやで豚丼を食べたりしていたのをきちんとカロリー計算して「おおお、これってこんなにカロリー高いのか！」と叫ぶだけでダイエットになった。レコーディングダイエットだとかそういうのが色々言われているけど、ようするに自分が何をどれだけ食べているのかに意識を向けるようにすることが一番大事なんだな。

*1225532547*もつ鍋を作る
f:id:nishiohirokazu:20081101184225j:image

大根は消費しきれないのでいつも避けていたんだけど小さい断片を売っていたのでそれを買ってきた。

f:id:nishiohirokazu:20081101184929j:image

よく見たらもつ鍋はもつとごぼうとニラとキャベツを入れるって書いてあるけどニラしか重複するものがない。煮立ってから野菜を入れるって書いてあるけど、大根や人参に火が通らないと思ったので最初に入れた。

f:id:nishiohirokazu:20081101190125j:image

ぐつぐつ。

f:id:nishiohirokazu:20081101191046j:image

ニラと白菜の固くない部分を入れた。

作って初めて知ったんだけど、もつってなんか臭いね。

-----

おいしかった。火が通るとにおいは気にならなくなった。

*1225542946*未来の食器洗い機(妄想)
遺伝子組み換えのアメーバがたくさん入っていて、特定の周波数の音を聞かせると興奮状態になって培養槽から出てきて食器についている有機物を食べてまわる。食料がある間はどんどん分裂してとにかく食べてまわる。食料がなくなってくるとアルコール発酵を始めて、食器洗い機内部のアルコール濃度の上昇をセンサーが感知してアメーバが家に帰りたくなる周波数の音を流す。アメーバが帰ったら食器洗い完了。


洗剤も水も全く使わないのでとてもエコです。副産物としてアルコールが取れるので消毒用にお使いください。流しの洗浄用に酢酸を作るモードにも切り替えられます。

*1225546707*test
>>
<aaa
<<

なんだこの&lt;/ppp>はw

>||
>>
<aaa
<<
||<

って書くと出現する。
</body>
<comments>
<comment>
<username>shinichiro_h</username>
<body>あーなるほど > ひっくりかえしてる<br><br>seen の方は、<br><br>       for(size_t i=0; i<hand.size(); i++){<br>           if (seen[i]) continue;<br>           for(size_t j=0; j<unknowns.size(); j++){<br>               if (seen[j]) continue;<br><br>ってことです。探索開始したら hand や unknowns は更新しない感じで。 7 * 15 * 15 * 7 * 15 * 15 くらいなら良さげに思いませんか。あと swap の方が良い気がします。<br><br>あと think_*_turns の速度は関数オブジェクトつっこめば余計なコストは無いかなぁと。 vector/list/deque の更新が発生しないようにしたら、たぶんボトルネックは点数計算なのでメンテナンス性優先して if で分岐しても別に構わないかなぁ…とは思いますが。</body>
<timestamp>1225521811</timestamp>
</comment>
<comment>
<username>nishiohirokazu</username>
<body>あ、そうか、なるほど。52 * 52 * 52である必要はないですね。悪くなさそう。<br> if (seen[unknowns[j]]) continue;ってやるか。hand_is_seen[7], unknown_is_seen[15]ってやるか。 <br><br>「関数オブジェクトをつっこむ」というのがよくわからないですけど、挙動の違う部分を関数オブジェクトにくくりだして「共通の処理」にその関数オブジェクトを与える形にすればコンパイラがインライン化してくれるはずだから呼び出しコストを追加で払う必要はないということでしょうか？</body>
<timestamp>1225524450</timestamp>
</comment>
<comment>
<username>shinichiro_h</username>
<body>実のところ深く考えてませんがそんな感じでたぶんいけるんじゃないかと > 関数オブジェクト<br><br>まぁ個人的には私は別にそこのコストは気にせんで良くね？と思っていますが。</body>
<timestamp>1225544948</timestamp>
</comment>
</comments>
```


[はてなダイアリー 2008-11-01](https://nishiohirokazu.hatenadiary.org/archive/2008/11/01)