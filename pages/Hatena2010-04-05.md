
hatena

```
<body>
*1270451834*月の列挙
<a href='http://d.hatena.ne.jp/Yoshiori/20100405/1270449443'>Python で次の月を求めようとしたらメンドそうなので Ruby にした - YoshioriのBlog</a>
<a href='http://d.hatena.ne.jp/atsuoishimoto/20100405'>2010-04-05 - atsuoishimotoの日記</a>

僕がYoshioriのブログから読み取った要求仕様ではdatetimeもcalendarも必要な気がしないのでKeep It Simpleで:

>|python|
year, month = 2005, 4

while (year, month) <= (2007, 04):
    print "%d%02d" % (year, month)
    month += 1
    if month == 13: 
        month = 1
        year += 1
||<

って書いてみたのであった。いまの暦では閏月とかないから、毎年1~12の月があるだけだし。

*1270468620*バトルコンビネータ 0.1
いきさつ
>>
kinaba ですです。これも含めて大好評でした。それにしても不思議ですねこれ。 RT @/kinaba (.)(.)(.)(.)(.)(.)(.)(.)(.)(.) == (.)(.)(.)(.)(.)(.) (via @/ksknac) http://twitter.com/ksknac/statuses/11587543440
<<
>>
nishio @/kinaba こういうのを利用したパズルとか作りたいのだけど未だに何も思いついていない。
<<
>>
kinaba @/nishio 『(.) の関数適用だけを使ってランダムに式を作る → 先手後手交互に、一手につき構文木を一カ所だけ（なにか決められた方法で）書き換える → 最初に元と意味的に同じ関数に戻した方が勝ち』…だめだ決着が付く気がしないし先手後手のどちらかが圧倒的に有利そう…(^^;
<<
僕の脳は「パズル=一人プレイ」に凝り固まっていたんだけど、交互に何かする対戦ゲームでもいいな、と思い始める。

以下自分の発言
>>
Bはこれなんだけど: http://en.wikipedia.org/wiki/B,C,K,W_system いろんな関数を魔法カードとして手札に持っていて…(やはり決着がつかない予感)
<<
>>
増えない関数に限定すればカードゲームとして実装できるから、交互にボード上の関数に引数を与えて、β簡約するのを繰り返してくのはできるなぁ。なにでスコアつけるのか謎だが。
<<
>>
テーブル上は2次元だから括弧が2個以上ネストすると表現できない… → 括弧を発生しうる関数を1枚だけしかデッキに入れなければいのか！
<<
>>
「出せるカードが無くなったら負け。テーブルの関数がIdentityになった時点で手持ちの関数の得点を合計して勝敗を決める」でいける気がしてきた。
<<
説明が抜けているけど、β簡約でテーブル上から取り除かれたカードはβ簡約した人の手札に入るつもりでいる。これを手札じゃなくて「獲得勝利点」にして「出せるカードが無くなったら負け」を取り除き、「テーブルの関数がもはやβ簡約できなくなったらゲーム終了」でもいい気がする。こっちの方がゲームが速やかに終わるし。

以下、「手札に入れる」バージョンをロング、「勝利点にする」バージョンをショートと呼ぶことにする。ショートは配牌による運の要素を克服出来る程度の長さがないと思う。

>>
Sコンビネータを入れないとゲームにならないと思っているけど、意外となくてもなんとかなるのかなぁ。そしてルールの中ではSコンビネータの挙動の理解が一番難しい。テーブルの上での表現も難しい。
<<

というわけでこんなカードになりました。

<img src="http://gyazo.com/208f6ddda8ae8581b65dccae85b374cb.png">

1pって書いてあるのは枚数＆得点。枚数が少ないカードの得点が低いことを疑問に思う人もいるかも知れないけど、得点の低い、枚数の少ないカードほど強力で一度に沢山のカードを得られるからって事でこうしてある。ロングのゲームだと手札の弱い高得点カードを出す(自分の読みが間違っていれば相手に高得点が渡ってしまう)かゲーム終了まで残しておくのかのジレンマになるかな、と。ショートだとあんまり悩みどころがないかも。

全部で15枚あるので、5枚ずつ配って、残りの5枚をテーブルにオープンする。オープンされたカードは「キュー」にいる。横に並べておいてあると思えばいい。今はIKTIIだとしよう。テーブルにはキューと「評価スペース」がある。評価スペースはキューと混同しないところならどこでもいい。縦方向に伸びるので下に余裕がある場所がいい。最大4枚。

>||
[(評価スペース)] IKTII
||<

交互にターンをプレイする。ターンは「関数を出すフェーズ」「キューの先頭を評価スペースに移すフェーズ」「評価フェーズ」の3つで構成される。
先手のターン、先手は「関数を出すフェーズ」でキューの末尾に、自分の手札の関数カードを1枚追加する。ここではCだとしよう。

>||
[(評価スペース)] IKTIIC
||<

次に「移すフェーズ」でキューの先頭のIを評価スペースに移す

>||
[I] KTIIC
||<

そして「評価フェーズ」では何も起こらない(後述)。後手のターン。後手は「関数を出すフェーズ」でキューの末尾に、自分の手札の関数カードを1枚追加する。Kを追加したことにする。

>||
[I] KTIICK
||<

次に「移すフェーズ」でキューの先頭のKを評価スペースに移す。IKって並んでいるけど、これ縦に並んでいると思ってね。

>||
[IK] KTIICK
||<

そして「評価フェーズ」では評価スペースの頭の関数を見る。カードIには「IX→X」という評価方法が書かれている。ので、評価スペースのIKをKに変更する。テーブル上にいらなくなったIは後手のものになる。

>||
[K] KTIICK
||<

先手のターン。関数カードを出す。えーと、少し考えてみよう。このターンの評価でKKが評価されず、後手でKKT→K、先手でKIで評価なし、後手でKII→I、先手でIC→C、後手でCKで評価なし、だな。ここで何を出したとしてもCは3引数をとるので評価されずCKx。後手のターンでCKxy→Kyx→y。後手にコンボを決められるところまで確定か。(あ、コンボの説明がなかったけど、ようするにそれ以上評価ができなくなるまで評価するので、TやCやSを使うと複数回の評価が起きる可能性があるのね。これがコンボ。)うむむ。そして残るカードはyなのでここで何を出しても無意味に後手にとられるだけか。じゃあこれショートのゲームだから点数の一番低いSを出しておくか。

>||
[KK] TIICKS
||<

後手のターン。後手の出すyは後で1枚だけになって先手の手番になるので、例えばここでIを出すとそのIは先手に確実に取られる。Kとか出すといいんじゃないかな。

<hr>

という感じに進んでいくゲーム。面白いかどうかはプレイしてみないとなー。

なおSの評価でzが2枚に増えるのをどう解決するかってのを書いておく。「ポインタカード」と「ポインタマーク」(コインみたいなの)を導入する。SXYZは評価前は縦に並んでいるのだが
>||
S
X
Y
Z
||<
これがPをポインタカード、*をポインタマークとして
>||
X
Z*
YP
||<
こうなる。Pは「ポインタの指している関数と同じ働きをする」ね。これでSxyz=xz(yz)になる。Pが残っている状態でZがテーブルから取り除かれた場合は、PのところにZを置く。ポインタが残っていたらGCされないってことだね。このSカードの導入でゲームに深みが増すのか、単に複雑になるだけなのかプレイしてみないとな。単に複雑なだけだったらλwxyz.zyxwとかと取り替えてもいいかも知れない。あとVx=Vとか導入するとどんなことになるのか。後は順当にプレイすると確定的すぎて面白くなかったら、各ユーザ1回ずつ「カードを出すフェーズ」でカードを出す代わりに「評価スペースを逆順にする」ができるようにするとか。「キューを逆順」でもいいかもな。
</body>
<comments>
<comment>
<username>atsuoishimoto</username>
<body>このケースなら私もこんな感じで書きますが、今回のはtimedeltaの利用例ってことで。datetimeのドキュメント、結構長くって読むの大変ですし。</body>
<timestamp>1270465630</timestamp>
</comment>
</comments>
```


[はてなダイアリー 2010-04-05](https://nishiohirokazu.hatenadiary.org/archive/2010/04/05)