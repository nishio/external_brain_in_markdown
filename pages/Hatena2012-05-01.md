---
title: "Hatena2012-05-01"
---

hatena

```
<body>
*1335846610*作りたいもの: プログラミング言語のコア概念を学ぶサイト
増井さんの<a href='http://www.scribd.com/doc/91645150/%E4%BD%9C%E3%82%8A%E3%81%9F%E3%81%84%E3%82%82%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86'>作りたいものリストを作ろう</a>というスライドを見て「確かに『いつかやる』リストに入れてるだけじゃ発展しないから、公開しても問題ないものは公開したらいいなぁ」と思ったので早速やってみました。とはいえ、僕の『いつかやる』リストは一つのリストの要素に色々な設計やアイデアが書かれていて、全部一度に載せると読むのも大変。とりあえず1つ目だけ載せてみます。動機なんかを加筆。


** プログラミング言語のコア概念を学ぶサイト

日本語や英語で書かれた解説を読むより、実際に動かしてみたほうがわかりやすいこともある。


しかし、広く使われている言語は既に長年の改良が繰り返されていて、改築・増築を繰り返した老舗旅館みたいに複雑なものになってしまっている。


学習のために、小さくシンプルな、全体像を理解しやすい、わかりやすく可視化された「言語の実装」が必要だ。

** そんなものはすでにあるのでは？

かつて色々な方法で(Javaアプレットで、Flashで、etc)、色々なアルゴリズムの可視化が試みられてきた。


適切な可視化手法は時代によって変わっていく。一方で、ある時代にアルゴリズムの可視化を実装した人が、みな5年後、10年後別の可視化手法への移植をするかというとそうではない。それがなぜなのかはわからない。可視化部分の習得コストが高いからか？


メンテナンスが継続されない問題はどうすれば解決できるか？コードが公開されていなかったり、されていてもライセンスが不明な点が問題の原因ではないか？であれば、GPLで公開すれば、将来の移植版も含めて再利用可能なライセンスであることを保証できるのではないか？


また、アルゴリズムの実装部分と可視化部分は疎結合であるべき。それによって移植性や再利用性が高まる。

** 適切なサイズ
ついつい機能追加をしてしまいがちだが、実装の読みやすさにも価値があることを考えると、最適なサイズは結構小さい。例えば中置記法のパーサの実装であれば「足し算と掛け算と括弧による優先順位の変更」だけ、とかが適切なサイズだと思う。

>>
これ以上付け加える物が無くなった時でなく、これ以上取り去る物が無くなった時が完成だ - アントワーヌ・ド・サン＝テグジュペリ
<<

** 実装するものリスト

何でもありだと力が分散してしまう。まずは集中するべき。今回は「JavaScriptで実装されていて、インストールなしで、ブラウザ上で動作する」に集中する。

- 構文木可視化部門
-- A: 構文木をSVGかcanvasで可視化する部品。汎用のツリー表示ライブラリが使えるかも。
-- シンプルな中置記法のコードをパースして構文木を作る部品。Aと結合して「ブラウザ上で1 * 2 + 3とか書くとリアルタイムで木がにょきにょき変形するのがわかる」というデモが出来る
-- 実用的に使われている言語の、構文木を作る部品とAとを結合させるアダプタ。JavaScriptのブラウザ上で動作するパーサは存在する http://esprima.org/demo/parse.html 後はこれの出力をAに送って可視化するだけ
-- LispのS式のパーサ。最低限数値と加算・乗算だけでよい。これもAに接続できるように
-- Forthのパーサ(って言うほどのものでもないか) Aに接続できるように

- スタックマシン部門
-- B: 「命令列のどこを実行しているか」と「スタックの状態」をわかりやすく可視化する部品
-- D: Forthの実装 これはほぼスタックマシンの実装と同義。最低限数値と加算・乗算だけでよい。Bと結合して可視化されること
-- スタックマシンを使っている言語のバイトコードを実行 たとえばPythonであれば文字列として受け取ったソースコードをバイトコードにコンパイルして返すHTTPサーバを書くことができるから、Pythonのバイトコードを実行するJSを書けばブラウザ上でステップ実行できる。Bと結合して可視化されること
-- Lispパーサの出力をForthにコンパイルしてDで動かす

- 構文木書換え部門
-- C: 構文木を部分的に書き換えていくことで計算を行う。Aと結合して可視化されること
-- Lispのパーサからの出力をCにつないで実行
-- Lazy K実装。Aと結合して実行過程が可視化される。

- 機械語部門
-- EDSACシミュレータ。シンプルな機械で機械語を学ぶために。ただし命令の読みにくさを保存する必要性はないのでわかりやすいエイリアスをつける。
-- Brainf*ck: ただし読みにくさを保存する必要はないので、わかりやすいエイリアスをつける、数値をstoreする命令を足す、などを行う。
-- 将来的には上記の機能限定されたForthやLispから機械語へのコンパイラを実装する。コンパイル過程を可視化する。

- その他
-- オブジェクトシステムの実装
-- スコープの実装
-- ガベージコレクション (thanks id:nisemono_san) 

*1335865812*作りたいもの: 1歩ずつミッションをクリアすることでGitの使い方を覚えられるゲーム
増井さんの<a href='http://www.scribd.com/doc/91645150/%E4%BD%9C%E3%82%8A%E3%81%9F%E3%81%84%E3%82%82%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86'>作りたいものリストを作ろう</a>というスライドを見て「確かに『いつかやる』リストに入れてるだけじゃ発展しないから、公開しても問題ないものは公開したらいいなぁ」と思ったので早速やってみました。2つ目。

** 1歩ずつミッションをクリアすることでGitの使い方を覚えられるゲーム

なんちゃらVille系のゲームはどうして人の心をとらえるのか？


「小さい粒度のミッションが提示されて、それを達成すると次のミッションが表示される仕組み」は、頻繁に「達成感」という報酬を与えることで人の心をとらえるのだろうか？


そういえば僕が昔書いた、対話的インタプリタで1歩ずつ操作しながらPythonを覚えるコンテンツも評判が良かったなぁ。だったらgitの使い方も、1歩ずつ対話的にミッションをクリアしながら学べるようにしたら面白いんじゃないか？

** 学習ユーザのユースケース
実は既にgithubにおいてあったりする。一応遊べる。 https://github.com/nishio/academy/blob/master/README_ja.rst

- 1: gitを学びたいユーザはこのリポジトリをクローンする
- 2: git/test.pyを実行する。これが実行できたら「クローンする」っていう最初のミッションはクリアしたってこと
- 3: test.pyが次のミッションを提示する。それを解く、を繰り返す。
- 4: やったー、ミッションを全部クリアした！gitを理解できたよー

** 何が不足か？

- 外見がかなりひどい
- 達成したミッションの一覧が見られると幸せ？
- 各環境で正しく動くことを確認するのは面倒(特にWindows)
- ユーザが何を入力したか、を確認する手段がない(historyをチェックするとか？)
- 現状、途中でつまずいた人を救済する方法が存在しない、というか何につまずいているかを僕が知る方法がない
- いっそPythonでシェルを乗っ取ってしまえばいいのか？termios？
- いま、ミッションを達成した時にCONGRATULATION!って出るだけで、すぐに次の問題が出ちゃう。ここではおめでとうメッセージと簡単な解説を出すだけにして、次のミッションを表示するのにもう1アクション挟んだほうがよさそう。
- ミッションの案は色々あるんだけど、まだ作ってない https://github.com/nishio/academy/blob/master/git/README.rst

*1335883422*作りたいもの: JavaScriptのコードの質を保つためのガードレール
増井さんの<a href='http://www.scribd.com/doc/91645150/%E4%BD%9C%E3%82%8A%E3%81%9F%E3%81%84%E3%82%82%E3%81%AE%E3%83%AA%E3%82%B9%E3%83%88%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86'>作りたいものリストを作ろう</a>というスライドを見て「確かに『いつかやる』リストに入れてるだけじゃ発展しないから、公開しても問題ないものは公開したらいいなぁ」と思ったので早速やってみました。3つ目。

** JavaScriptのコードの質を保つためのガードレール

JavaScriptは柔らかい言語で、typoとか変数名の変え忘れが実行時までエラーにならない。しかもしれっとundefinedとかになって、そのままHTMLやSVGのpath文字列に埋め込まれてたりしてデバッグにコストが掛かってしまう。人間は間違える生き物だから、間違いをなくすことはできない。だから間違えた時になるべく早く気づけるようにする仕組みが必要だ。


Google Closure CompilerはJavaScriptのソースコードを静的に検証してエラーを報告してくれる。であれば自分がソースコードを編集している時にバックグラウンドでがんがんコンパイルしてエラーが見つかり次第報告してくれればいいんじゃないか。

** jscc: JavaScript Continuous Compilation

実は既に作って公開してある。http://nishio.github.com/jscc/

<img src="http://nishio.github.com/jscc/screenshot.png">

ファイルを編集するとwatchmedoでGoogle Closure CompilerとLintが実行され、グラフが自動更新される。コンパイルエラーがあれば赤、警告があれば黄色、両方なければ緑になる。僕がJSでコードを書く際には、デュアルモニターの端っこでこれを表示して、普段は注視しないでコードを書いていて、赤や黄色に変わると視野の端にあっても色が変わったことに気づくのでエラーログを確認する、というやり方をしている。

** 問題点

- インストール周りがひどい。プロジェクトのルートディレクトリに3つシンボリックリンクを作るだけ。しかもそのうち1つはMakefile。
- コンパイル結果とLintの結果がプロジェクトルートのcompile.logとlint.logに作られる。コンパイラが多重起動しないためのロックファイルもそこに作られる。プロジェクトを汚しまくりなのでこれは別のところにおいたほうがいいと思う。


- watch周り
-- Windows(cygwin)だとwatchmedoがうまく動かないという報告があった。
-- 現状、watchしているプロセスを殺す方法がない。どうするのがよいか？
-- watchmedoを使っていると、git statusやgit add -pでコンパイルが始まってしまう謎
-- →いっそwatchmedoを使うのは辞めて、Pythonでファイルの更新日時を定期ポーリングするコードを書いた方がよい？

- クライアントツール
-- Makefileとbuild.shとclient.pyをカレントディレクトリにln -sする設計になっているけど、そもそもプロジェクトの内容に応じて書き換える必要があるのはMakefileだけだから残りの2つはjscc/client/に置きっぱなしでいいんじゃない？compile.logとlint.logもjsccの中に作ったほうがいいんじゃない？なるべく汚さない方針で。
-- flymakeと統合？エラーの行をemacs上で表示したら幸せになれる？
-- 将来的に複数のプロジェクトで複数人で使う際には識別のためにプロジェクト名とユーザ名を送る必要がある。今は一人で使う想定でシングルユーザ・シングルプロジェクト
-- growlnotifyは必須ではないので(僕は使うけど)インストールされてるかどうか判断して使うようにしたいがどう書く？

- 可視化サーバ
-- 今はシングルユーザ・シングルプロジェクトなのでトップページでそのままグラフが見えるけど、将来的に複数のプロジェクトと複数人で使う場合にはトップページはプロジェクト一覧にして /project_name/nishio/ みたいなURLで見るようにするべき
-- いま過去の履歴を保存していない。sqliteかなんかで保存しておく。最新n件を取るAPIが必要。
-- 今はJSで1秒1回サーバにポーリングしているが、タイムアウトしてないせいでサーバが止まっているとリクエストが溜まってしまう？どうするのがよい？Comet？
</body>
```


[はてなダイアリー 2012-05-01](https://nishiohirokazu.hatenadiary.org/archive/2012/05/01)