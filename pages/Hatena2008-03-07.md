
hatena

```
<body>
*1204857266*codepad
http://codepad.org/mKIPLgX6
>|python|
import time
time.sleep(1000)
||<

>>
Disallowed system call: SYS__newselect
<<

へー。そうなるのかー。

*1204860617*体重

荷物少なめにしたのに１５キロ重いよ！

*1204862739*新宿

スーパーあずさが何線かメモするの忘れた。JRだとおもうけど。

*1204863920*改札

切符を買ったら二枚渡されたので二枚で改札に入れたら詰まった。そのままお待ちください、と出たけど駅員がなかなか来なかった。次の電車は２時発なので５時頃着くかな。

*1204865496*電源

あずさには普通の形のコンセントがあった。

*1204868134*もう甲府

近いな！
モチフィーユ一個売ってほしい。食べてみたいけど箱で買う勇気はない。

*1204870674*地理

長野と甲府と大垣の位置関係がわかりません。最初は松本を関西だと思っていたので。

なんだ次が甲府だ。おかしいと思った。

*1204871123*新幹線との違い

酔う。

*1204873438*超接近

座っている席の目の前だった
f:id:nishiohirokazu:20080307160348j:image

*1204875136*松本

着いたよ。寒い。ケアレスミス発覚。会場の名前をメモするの忘れた。

*1204876600*交番
f:id:nishiohirokazu:20080307165637j:image

*1204878438*ついた
迷ったけどついたよ！

Unittestの授業が始まっている。なんとなくでMacBookを取り出した。勉強している過程を録画しておいてあとでニコニコにアップとか面白いと今気づいたんだけど、会場のネットワークの状況がつかめていないのでUstreamにつなぐのがためらわれる。上り帯域とっちゃうとまずいかもしれない。ローカルで録画できる仕組みを用意しておくべきだと思った。

*1204880561*テスト
- 動かない（テスト含む）→汚いけど動く→きれいにする→くりかえし

*1204880641*MacBook3日目
MacBookから編集中
Emacsを使っているのにメタキーがどれかわからなくて試行錯誤の末、Escだと気がついた。遠いよ＞＜

*1204889167*まぶしい
部屋の照明がまぶしすぎる件…orz

*1204889862*飲食厳禁
飲食厳禁の会議室のガラスのコップが用意されている不思議

*1204890556*class precedence list
http://gauche.sourceforge.jp/doc/gauche-refj_141.html

勉強中。余計なことに手を出してしまった気がする。

>>
Gauche ではデフォルトで C3 線形化と呼ばれているアルゴリズムを使います。このアルゴリズムは局所的な順位、単調性、拡張順位グラフと整合性のとれたものです。ここでは詳細に立ち入りませんが、一般的なルールとして、 CPL 中のスーパークラスの順序は、つねにそのクラスの直接スーパークラスの順序、それぞれのスーパークラスの CPL の順序、および、各スーパークラスの直接スーパークラスの順序、などと整合性をもちます。正確な説明についてはDylanを参照してください。
<<

ああっ。詳細に立ち入ってくれていない＞＜
ぼ、ぼくも詳細に立ち入るのやめようかな。
それぞれのCPLがスーパークラスを指定する順序やスーパークラス達のCPLと同じ順になっている(「片方でAがBより先にあるのに別のではBがAより先にある」ということがおこらない)ってことだけ解説すればいいかなぁ。

Pythonの新しいクラスの継承がC3線形化なのですけど、どう説明すればいいかなぁとか。

単純に「昔は深さ優先だったのが幅優先になっただけ」という理解は間違いだと言うことには言及すべきだろうしなぁ。

やっぱり説明しないわけにはいかない。ついつい「筆者の理解が正しければ」って書きたくなってしまうが、基本的に全ての言及は間違っている可能性があるわけだから無意味だよな。ここに書いておいて識者から「それは違う」とつっこまれたら修正することにしよう。

*1204893212*[Python]メソッドの検索順序
Python2.3以降の新しいクラスは、メソッドの検索順序(MRO, Method Resolution Order)が「C3線形化」というアルゴリズムに変更されている。このアルゴリズムについて解説する。

まずは実例。
>|python|
>>> class A(object): x = "a"
>>> class B(A): pass
>>> class C(A): x = "c"
>>> class D(object): x = "d"
>>> class E(B, C, D): pass
>>> e = E()
>>> e.x
'c'
||<
クラスの検索順序が深さ優先探索ではないことがわかると思う。

C3線形化の特徴はメソッドを探す順番が
- クラスXがYを継承しているなら必ずXがYより先にくる
- クラスXがY, Zという順で継承しているならYは必ずZより先に来る
- 他のクラスのメソッド探索順でXがYより先に来ているなら、他のクラスの探索順でも必ずXはYの前にある
という3つの条件を満たすことである。

かりにメソッド探索の順番が深さ優先探索だと、上のE.xはまずEの中で探して、次にBの中を探し、次にBの親クラスであるAの中を探す。そうすると実際にはCがAを継承しているにもかかわらずAが先に検索されてしまうためC.xでオーバーライドされているのが反映されない。これがPython2.2以前の挙動。

幅優先でない証拠は下記
>|python|
>>> class A(object): x = "a"
>>> class B(A): pass
>>> class C(object): x = "c"
>>> class D(B, C): pass
>>> d = D()
>>> d.x
'a'
||<
幅優先探索ならD→B→C→Aの順に検索されることになるが、それではBはAからxを継承しているはずなのにC.xの値が返ってしまう。Pythonは実際にはD→B→A→Cの順に探索している。

まずクラスがどういう順になっているかというリスト(CPL)を作るアルゴリズム。
<del>
- [B, A, object]
- [C, object]
- [D, B, C]

これを並べるときに、まずobjectの部分がマージされて
- [((B, A) | C), object]
こんな感じになる。ここで(B, A)とCのどっちを前にするか考えるわけだけど、[D, B, C]の中でBが先になっているから
- [B, A, C, object]
こうなる。最後にこれと無矛盾なD, B, Cがマージされて
- [D, B, A, C, object]
こうなる。

最初の例は
- [B, A, object]
- [C, A, object]
- [D, object]
- [E, B, C, D]
だった。これも
- [((B, A) | (C, A) | D), object]
こうなって、BやCよりDがあとなので
- [(B | C), A, D, object]
こうなって、BがCより前なので
- [B, C, A, D, object]
こうなって最後に
- [E, B, C, A, D, object]
こうなる。

で、いいのかな？ちがうかな。
</del>

クラスが定義されたときに順番が決まるべきか。
つまり、
- [A, object]
がまず決まって、次にB(A)で
- [B, A, object]
C(A)で
- [C, A, object]
となって、最後にD(B, C)で
- [D,
まで来たときに、どれを選ぶか、と言う話でD(B,C)だからBが選ばれ
- [D, B
となり、次はAとCのどちらを選ぶかという話になって、CのCPLにAが含まれているからCが先に来て
- [D, B, C, A, object]
ってなるんかな。

2番目の例だと
-[A, object]
-[B, A, object]
-[C, A, object]
-[D, object]
-[E,
でE(B, C, D)だからBが選ばれ
-[E, B,
Bの次のAとCとDだと、CのCPLがAを含んでいるので先に来て
-[E, B, C,
Bの次のAとDだと、DのCPLはAを含んでいなくてBが含んでいるのでE(B, C, D)の順に従ってAが選ばれ
-[E, B, C, A, 
Aの次のobjectとDだとDのCPLがobjectを含んでいるのでDが先に来て
-[E, B, C, A, D, object]
となるのか。

うん、こっちの方が実装として普通そうだ。

-----
The Python 2.3 Method Resolution Order
http://www.python.org/download/releases/2.3/mro/index.html#the-c3-method-resolution-order

ここの説明がとてもわかりやすかった。

*1204895684*Gainer
となりでGainerいじりをしているチームがとても楽しそうだが原稿がぜんぜん完成していない。「JavaとPythonの比較を書くなら多重継承ができる話を書かずにどうする！」と思って書き始めてしまったのが最大の失敗だ。でも書く。

とりあえず黄色い本は注文しよう。

*1204901016*暑いなー
人が多いのでとても暑い
飲み会のターン。

多重継承の話を少し寝かせて(そんなことを言っている場合かと思うが)すでに書いた文章のレビューをさっさとやらねば。

*1204903768*Zen of Python 関西弁版
infoseekの関西弁翻訳でThe Zen of Pythonを翻訳
http://translation.infoseek.co.jp/

>>
パイソンの禅（ティムピータースによる）

醜いより、美はよいや。
内在するねんより、完はよいや。
複合体よりよいものは、単純や。
難しくなるより、複合体はよいや。
縮小であるより、フラットはよいや。
濃いものよりよいものはまばらや。
読みやすさは数えまんねん。
特例は、規則を破るのに十分特別でおまへん。
実際性が純度を打つが。
エラーは、黙って決して通ってはいけまへん。
はっきりと沈黙せん限り。
曖昧さに直面して、推測したいちう誘惑を拒否してくれまっか。
明らやろか方法でそれをするねんために、もの ― 望ましくはとわずか1 ― がなければなりまへん。
あんはんがオランダ人でない限りその方法が最初は明らかでないかもしれへんが。
現在、決してよりよいや。
せやけど、現在、*right*よりしばしば決してよくおまへん。
実施が説明するねんのがややこしいならば、それは間ちゃうた考えや。
実施が説明するねんのが簡単であるならば、それはええ考えであるかもしれまへん。
名前空間は1つの警笛を鳴らしとる素晴らしいアイディアや－それらのよりようけをしまひょ！
<<

>>
パイソンの禅（ティムピータースによる/西尾泰和による添削）

きたないのんより、きれいなのがええねん。
中に隠れてんのより、外に出てんのがええねん。
<<

ダメだ、添削じゃなくて翻訳し直しになる。そんなことしている場合じゃない。

英文を読まない方針で最小限の修正で整える。
>>
パイソンの禅（ティムピータースによる/西尾泰和による添削）

醜いのんより、美しいのがよいや。
内在するのんより、完がよいや。
複合体よりよいものは、単純や。
難しくなるよりは、複合体でよいや。
凝縮してあるより、フラットがよいや。
濃いのんより、まばらなんがええねん。
読みやすさは重要やねん。
特例は、規則を破るのに十分特別でおまへん。
実用性が純度より大事。
エラーは、黙って通したらいけまへん。
はっきりと沈黙させられてへん限りは。
曖昧さに直面して、推測したいちう誘惑は拒否してくれまっか。
明らやろか方法でそれをするために一つのもの ― 望ましくは一つだけのもの ― がなければあきまへん。
あんはんがオランダ人でない限りその方法が明らかでないかもしれへんが。
今やるんは、決してやらへんよりよいや。
せやけど、やらへんのは今すぐするよりは、しばしばええで。
実装を説明するんがややこしいならば、それは間違ごうとるねん。
実施が説明するんが簡単ならば、それはええアイデアかもしれまへん。
名前空間はめっちゃええアイディアや－それらよりようけしまひょ！
<<

*1204904641*IronPython Studio
IronPython Studio - Home
http://www.codeplex.com/IronPythonStudio
</body>
<comments>
<comment>
<username>earth2001y</username>
<body>ビバ振り子車両</body>
<timestamp>1204876163</timestamp>
</comment>
<comment>
<username>yokochie</username>
<body>コマンドキーがメタキーになるはずですよ。あと、”(setq mac-option-modifier ’meta)”でoptionキーがメタキーになりますよ。 via http://homepage.mac.com/zenitani/emacs-j.html</body>
<timestamp>1204885160</timestamp>
</comment>
</comments>
```


[はてなダイアリー 2008-03-07](https://nishiohirokazu.hatenadiary.org/archive/2008/03/07)