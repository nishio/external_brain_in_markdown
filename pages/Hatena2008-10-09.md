---
title: "Hatena2008-10-09"
---

hatena

```
<body>
*1223570211*[TopCoder]SRM421 Div1 easy
http://www.topcoder.com/stat?c=problem_statement&pm=10104&rd=13512
直線上のx[i]の位置にm[i]の質量がn個並んでいる。万有引力は距離の二乗に反比例する。別のものを置いたときにプラス方向へ引く力とマイナス方向へ引く力が釣り合うポイントがn-1個あることがわかっている。これを求めよ。って問題。

チャットから引用
>>
それは二分探索で普通に解けた。
上限をx[i+1], 下限をx[i]にして
pos = (上限 + 下限) / 2にして
posの位置でどっち方向の力が強いか計算する

上に引っ張ってたら上により過ぎだからもっと下がらないと行けない
上限 = posして繰り返し

上限と下限の差が要求されている制度より狭くなったらbreak

これでおわり
<<

上の説明では言及していないけど、与えられた各質量の間に1個ずつしか釣り合いの点がないことが自明じゃない人もいるかと思うので簡単に説明する。
２つの質量の間の点に注目する。その点の少しプラス側では、プラス側にある質量に近づいたのでプラス方向に引く力が強まり、逆にマイナスに引く力は弱まる。この二つの力が一致する点が釣り合いの点なので、これは２つの質量の間には１個しかない。(下がるばっかりの線と上がるばっかりの線は１カ所でしか交差しないよね）

>|cpp|
  vector <double> getPoints(vector <int> x, vector <int> m) {
    vector<double> result;
    size_t N = x.size();
    for(size_t i=0; i<N-1; i++){
      double ub = x[i + 1];
      double lb = x[i];
      while(true){
	double pos = (ub + lb) / 2;
	double lforce = 0.0, uforce = 0.0;
	for(size_t j=0; j<=i; j++){
	  double d = x[j] - pos;
	  lforce += m[j] / d / d;
	}
	for(size_t j=i+1; j<N; j++){
	  double d = x[j] - pos;
	  uforce += m[j] / d / d;
	}
	if(uforce > lforce){
	  ub = pos;
	}else{
	  lb = pos;
	}
	if(ub - lb < 1e-10){
	  result += pos;
	  break;
	};
      }
    }
    return result;
  }
||<

ちなみに、result += posはvector<double>に対して+=しているわけだけど、これって意外と知らないひとが多いね。boost/assign.hppを使っています。push_backって長くて面倒だもの。

*1223570694*[TopCoder]戦線布告された
http://generation1986.g.hatena.ne.jp/n4_t/20081009
>>
まずはnishioさんを追撃、であります。
<<

今年の頭にも戦線布告されたんだけど http://d.hatena.ne.jp/nishiohirokazu/20080101/1199187895

調べてみたら、12ポイント差だった。知らない間に背後につかれていた。怖い怖い。

*1223572405*[TopCoder]SRM421 Div1 normalがわからない
http://www.topcoder.com/stat?c=problem_statement&pm=10074&rd=13512
整数のリストが与えられる。これはケーキのサイズ。これを最大maxCuts回切って、一番大きい断片と一番小さい断片のサイズの差が一番小さくなるようにせよ、という問題。どうするんだこれ。
>>
CONSTRAINTS
-weights will contain between 1 and 50 elements, inclusive.
-Each element of weights will be between 1 and 1,000,000,000, inclusive.
-maxCuts will be between 1 and 100,000, inclusive.
<<

切断数を1個ずつ増やしながら探索するとかでは無理そう。ケーキのサイズは最大1,000,000,000で、許される切断の回数は最大100,000回。ケーキは最大50個。

ちなみに問題文には書かれていないけども、ケーキをn回切るときにはn等分すると考えていい。なぜかというと、等分してない場合で、断片のどれかが最大もしくは最小になる場合、等分すれば最大の断片はもっと小さくなり、最小の断片はもっと大きくなるので、より「差の小さい」状態が存在することになる。逆に最大でも最小でもない場合、答えに影響しないので等分でもかまわない。よって常に等分する条件を付け加えても答えは変わらない。

-----

漠然と考えてわからないときは端から考える。まずケーキが1個のときは分割数関係なく0.0を返す。ケーキがいくつかあって分割数の上限が0回の場合、答えはたんに最大値と最小値の差。

ケーキが2個あって、分割数が1の時を考える。分割するのは大きい方。大きい方をa, 小さい方をbとする。a == bなら分割しなくていい。分割後の差b - a / 2がa - bより大きければ分割しないでいい。つまりbがa * 3 / 4より大きければ分割する必要がある。

分割数は1のままで、ケーキがたくさんある場合。分割するのは最大のケーキ。なぜなら、そうでない場合は最大と最小の差が変化しないか増えるかのどちらかだから。最大のピースを分割して、最小を下回らない場合、これは他のピースのサイズによらず差が縮まる。下回る場合が厄介。つまりmax / 2 < min の場合、2番目に大きいケーキを2ndとして、max - min > 2nd - max / 2 が成り立つかどうかが分かれ目。

うーん。

切断数の上限が2の場合、maxを3分割する選択肢と、maxと2ndをそれぞれ2分割する選択肢がある。

うーん、道筋が見えないぞ。 

(続きは後で書く)
</body>
```


[はてなダイアリー 2008-10-09](https://nishiohirokazu.hatenadiary.org/archive/2008/10/09)