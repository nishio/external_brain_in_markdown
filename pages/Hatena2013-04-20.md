---
title: "Hatena2013-04-20"
---

hatena

```
<body>
*1366388496*評価戦略について
「<a href="http://www.amazon.co.jp/gp/product/477415654X/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=477415654X&linkCode=as2&tag=nishiohirokaz-22">コーディングを支える技術</a>」の書評で、評価戦略についていくつかご意見をいただきました。

>>
id:dankogai  評価戦略がまるまる抜けてしまったのは残念である。かつては事実上先行評価しかなく、評価戦略において選択肢があること自体ほとんど知られていなかったが、今では遅延評価を主体とする言語も普及したとまでは言えないものの、充分実用的に使われるようになってきている。著者はもちろんHaskellを知っているし、本書にも登場するにも関わらず、これが抜けているというのはなんとももったいない。もし改訂版を著す機会があったら、絶対に一章割いていただきたい。
<<
http://blog.livedoor.jp/dankogai/archives/51864510.html


確かに、世の中の大部分の言語が先行評価なせいで「そういうもんだ」と思い込んでしまっている人も多そうですね。そういう人にHaskellでunsafePerformIOとか使って「ほら違う言語もある」と見せてあげると目からウロコを落とせていいかもしれません。その上でサンクとかの説明に進むか、それとも時代を遡ってALGOL 60の名前渡しとかの話をするか…。


>>
id:matarillo 先行／遅延がないという指摘。ifや?:の話にからめて正格／非正格の話をしてもよかったはず。(ifを関数にできるか？とかそういうヤーツ)
<<
http://b.hatena.ne.jp/entry/blog.livedoor.jp/dankogai/archives/51864510.html


なるほど、Smalltalkが条件分岐を実現している仕組みを解説するとか、LISPのマクロを使って自分でifを作ってみるっていうのも面白いかもしれませんね。


…と普段だとこれくらいで済ませてしまうのですが、これはきっと弾さんのような「わかっている人」を読者として想定しているせいなんですね。このテンションで書籍の原稿を書いてしまうと読者は置いてけぼりになってしまいます。

そこで、本の下書きを書くつもりでブログ記事を書いて公開することにします。

<hr>

関数fooと関数barが foo(bar(1)) という形で使われていたら、どちらの関数が先に呼ばれるでしょうか？

例えばPythonで下のようなコードを書いて実行したらどうなるでしょう？

>|python|
def foo(x):
    print "foo"
    return x + 1

def bar(x):
    print "bar"
    return x * 2

print foo(bar(1))
||<

このコードの実行結果は以下のようになります。barが先に呼ばれているわけです。

>||
bar
foo
3
||<

この結果に驚く人はさほど多くないかなと思います。C言語でもJavaでも同じ挙動ですから。

でも、この挙動はすべての言語で共通というわけではありません。Haskellの例を見てみましょう。

>|haskell|
import System.IO.Unsafe

foo x = unsafePerformIO $ do
          print "foo"
          return (x + 1)

bar x = unsafePerformIO $ do
          print "bar"
          return (x * 2)

main = print $ foo(bar(1))
||<

このコードの実行結果は以下のようになります。先ほどと違ってfooが先に呼ばれていることがわかりますね。

>||
"foo"
"bar"
3
||<

このように「どこから先に評価するか」（評価戦略）は言語によって異なります。多くの言語は、関数 foo の引数 bar(1) を関数 foo より前に評価します。これを「正格評価」と言います。一方Haskellは正格でない評価（通称「遅延評価」）がデフォルトの挙動です。（脚注：seqや$!などの正格評価をするためだけの関数や演算子が用意されているので、正格評価が必要な時にはこれらを使います。）

<hr>
続き（予定）
- 遅延評価のメリット：必要ないものは計算しない
- 遅延評価の仕組み：「あとでやる」の話
- 遅延評価のコスト：「あとでやる」を覚えておくために消費されるメモリの話

…これだと名前渡しやSmalltalkの出番がないですねぇ。
<hr>
追記：今回はunsafePerformIOという裏口を使って無理やりどちらが先に評価されているかを観察してますが、コンパイラにとってはfooから評価してもbarから評価しても「計算結果が3になる」という結論は変わりません。そこでコンパイラが何らかの都合で「barを先に評価したいな」と考え、barを先に評価する可能性は否定できません。「bar(1) を関数 foo より前に評価する」のが正格評価、「fooを先に評価するかもしれないし、barを先に評価するかもしれない」のが正格でない評価、というわけです。
<hr>

拙著「<a href="http://www.amazon.co.jp/gp/product/477415654X/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=477415654X&linkCode=as2&tag=nishiohirokaz-22">コーディングを支える技術</a>」の読者から頂いた質問など対して、こんな感じで補足記事を書いて行きたいと思っています。質問・感想はおきがねなくどうぞ。

拙著に関する他のエントリーは「<a href='http://nhiro.org/langbook/'>「コーディングを支える技術」著者公式ページ</a>」からたどれるようにします。

<iframe src="http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=AAFFAA&fc1=000000&lc1=0000FF&t=nishiohirokaz-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=477415654X" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

*1366462179*DE0でFPGAのチップ内蔵RAMをVRAMに使おうとしたら上手く行かなかった日記
手順としてはこちらに書かれている通り「<a href='http://d.hatena.ne.jp/nowokay/20130116/1358331649'>DE0でFPGAのチップ内蔵RAMにアクセスする - きしだのはてな</a>」

「RAM: 2-PORT」を選んで、1ポートずつread/writeに割り当て。モノクロ640x480ピクセルのVRAMを作りたかったので、How many bits for memoryに307200bitと指定した。Resource Usageは48 lut + 40 M9K + 6 reg。僕が使っているDE0はマニュアルによれば「56 M9K Embedded Memory Blocks」と書いてあるので、40個のM9Kブロックを使うことはおかしくないはずだ。

しかしこれをVRAMに使って絵を描いてみると、なぜか5箇所ぐらいに同じ絵が出たり、絵の表示されないゾーンが出来たり、とおかしな挙動をする。

試しにメモリの先頭から1024bitずつ0と1で埋めてみた。画面の横幅が640pxなので、1024bitずつ交互に塗れば「太さが1または2の横縞模様」ができるはず。しかし縞模様が10本描かれた(つまり20480bit)後、残りがベタ塗りになってしまった。下の写真で縞模様になっているゾーンが5つあるけど、頭から埋めていく過程で5箇所同時に縞模様が書かれて、青いゾーンには一瞬で青くなった。つまり限界ギリギリの場所にあるおそらく1bitのメモリを埋めるとこの青いゾーンが全部青になってしまうってことか。何が起きているのやらさっぱり。

M9Kメモリブロックはパリティを含んで9216bitのメモリなので、有効に使えるのは8192bit。20480bitとの関連性もさっぱりわからない。

[f:id:nishiohirokazu:20130420214711j:image]

しかたがないので使えそうな前半の20480bitに収まるように、4x4ピクセルで1bitににして160x120の解像度にしたものがこちら。160 * 120は19200だ。メモリがおかしくさえなければちゃんと期待通りに動くんだから、やっぱ問題はRAMの側かなぁ。307200bitも確保することが予想されておらずアドレスの指定に関する回路がおかしくなっているとかなのかなぁ。なにぶんFPGAは素人なのでどう解決したらいいかがわからない。

[f:id:nishiohirokazu:20130420214710j:image]

ところで160x120のモノクロでも楽しめそうなものはなにかないか考えた結果、ライフゲームを実装しようと思っているのだけど、ダブルバッファリングはどうするのが一般的なのかなぁ。普通に同じサイズのRAMを2つ作って、1bitのフラグでどっちから読んでどっちに書くかをif文で分岐するのでいいのかなぁ。

ルール部分は512bitのROMでテーブル引きにしたらいいと思っている。

とりあえずシンプルに実装すると9クロック掛けて9箇所のピクセルデータを読んで、その値でテーブル引きして書き込む、という形になるかと思うけど、せっかくFPGAなのに1ピクセルに9クロックも掛けるのがもったいないと思うのでもっと並列化したい。どうしたらいいのだろうか。RAMのreadポートを9本にしたりできたらいいんだけどウィザードでは2ポートまでしか作れない。それとも323bitのシフトレジスタを用意して2行+3px分のデータをそこに溜めながらスライドしていく？
</body>
```


[はてなダイアリー 2013-04-20](https://nishiohirokazu.hatenadiary.org/archive/2013/04/20)